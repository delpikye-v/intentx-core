let t=0;function e(e){return Symbol(null!=e?e:"scope-"+ ++t)}const n={high:[],normal:[],low:[]};let o=!1;function l(){var t;o=!0;for(const e of["high","normal","low"])for(;n[e].length;)null===(t=n[e].shift())||void 0===t||t();o=!1}function c(t,e="normal"){n[e].push(t),o||queueMicrotask(l)}const r={activeNode:null,activeEffect:null};let a=0;function i(t,e){return{id:++a,type:t,label:e,deps:new Set}}function u(t,e="normal"){const n=i("effect","reactive");let o=!1;const l=()=>{if(!o)try{r.activeNode=n,r.activeEffect=l,t()}finally{r.activeNode=null,r.activeEffect=null}};return c(l,e),()=>{o=!0,n.deps.clear()}}let f=!1;const s=new Set;let d="low";function v(t){f=!0;try{t()}finally{f=!1,s.forEach(t=>c(t,d)),s.clear(),d="low"}}function h(t){let e,n=!0;const o=new Set,l=i("computed"),a=()=>{n||(n=!0,o.forEach(t=>{return e=t,n="normal",void(f?(s.add(e),"low"===d&&(d="normal")):c(e,n));var e,n}))};return()=>{if(r.activeNode&&r.activeNode.deps.add(l),r.activeEffect&&o.add(r.activeEffect),n){const o=r.activeNode,c=r.activeEffect;r.activeNode=l,r.activeEffect=a,e=t(),n=!1,r.activeNode=o,r.activeEffect=c}return e}}const p=e("default");function g(t){const e=new Map,n=new Map,o=t=>null!=t?t:p;return{on(t,n,l){var c,r;const a=o(l),i=null!==(c=e.get(t))&&void 0!==c?c:new Map,u=null!==(r=i.get(a))&&void 0!==r?r:[];u.push(n),i.set(a,u),e.set(t,i)},effect(t,e,l){var c,r;const a=o(l),i=null!==(c=n.get(t))&&void 0!==c?c:new Map,u=null!==(r=i.get(a))&&void 0!==r?r:[];u.push(e),i.set(a,u),n.set(t,i)},async emit(l,c,r){var a,i,u;const f=o(r),s=null===(a=e.get(l))||void 0===a?void 0:a.get(f);if(!(null==s?void 0:s.length))return;const d=t(c,f),v=null!==(u=null===(i=n.get(l))||void 0===i?void 0:i.get(f))&&void 0!==u?u:[];for(const t of s){const e=v.reduceRight((t,e)=>e(t),t);await e(d)}},scope:p}}function w(t){const e=[],n=()=>t=>e.reduceRight((t,e)=>e(t),t);return n.takeLatest=()=>{let t=null;return e.push(e=>async n=>(null==t||t.abort(),t=new AbortController,e({...n,signal:t.signal}))),n},n.takeLeading=()=>{let t=!1;return e.push(e=>async n=>{if(!t){t=!0;try{return await e(n)}finally{t=!1}}}),n},n.debounce=t=>{let o;return e.push(e=>n=>new Promise(l=>{clearTimeout(o),o=setTimeout(()=>l(e(n)),t)})),n},n.throttle=t=>{let o=0;return e.push(e=>async n=>{const l=Date.now();if(l-o>=t)return o=l,e(n)}),n},n}export{v as batch,h as createComputed,g as createIntentBus,e as createScope,w as intentEffect,u as reactiveEffect,c as schedule};
