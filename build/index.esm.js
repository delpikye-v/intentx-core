let e=0;function t(t){return Symbol(null!=t?t:"scope-"+ ++e)}const n={high:new Set,normal:new Set,low:new Set};let o=!1;function c(){o=!0;for(const e of["high","normal","low"])for(const t of n[e])n[e].delete(t),t();o=!1}function l(e,t="normal"){n[t].add(e),o||queueMicrotask(c)}let r=!1;const a=new Set;let i="low";function s(e){r=!0;try{e()}finally{r=!1;for(const e of a)l(e,i);a.clear(),i="low"}}function u(e,t){r?(a.add(e),"high"===t?i="high":"normal"===t&&"low"===i&&(i="normal")):l(e,t)}const f={activeEffect:null,activeDeps:null};function d(e){let t,n=!0;const o=new Set,c=new Set,l=()=>{n||(n=!0,o.forEach(e=>u(e,"normal")))};return()=>{var r;const a=f.activeEffect;if(a&&(o.add(a),null===(r=f.activeDeps)||void 0===r||r.add(o)),n){for(const e of c)e.delete(l);c.clear();const o=f.activeEffect,r=f.activeDeps;f.activeEffect=l,f.activeDeps=c,t=e(),n=!1,f.activeEffect=o,f.activeDeps=r}return t}}function v(e,t){return function(n,o="normal"){let c=!1;const l=new Set,r=()=>{if(!c){for(const e of l)e.delete(r);l.clear();try{e.activeEffect=r,e.activeDeps=l,n()}finally{e.activeEffect=null,e.activeDeps=null}}};return t(r,o),()=>{c=!0;for(const e of l)e.delete(r);l.clear()}}}const p={activeNode:null};let w=0;function g(e){const t={id:++w,type:"computed",label:n,deps:new Set};var n;const o=d(()=>{const n=p.activeNode;p.activeNode=t;try{return e()}finally{p.activeNode=n}});return()=>{const e=p.activeNode;return e&&e.deps.add(t),o()}}const h=v(f,l);function y(e){let t=e;const n=new Set,o=()=>{const e=f.activeEffect;return e&&(n.add(e),f.activeDeps&&f.activeDeps.add(n)),t};return o.set=(e,o="normal")=>{Object.is(e,t)||(t=e,n.forEach(e=>{e!==f.activeEffect&&u(e,o)}))},o.subscribe=e=>(n.add(e),()=>{n.delete(e)}),o}const m=t("default");function E(e){const t=new Map,n=new Map,o=e=>null!=e?e:m;return{on(e,n,c){const l=o(c),r=function(e,n){var o,c;const l=null!==(o=t.get(e))&&void 0!==o?o:new Map,r=null!==(c=l.get(n))&&void 0!==c?c:new Set;return l.set(n,r),t.set(e,l),r}(e,l);return r.add(n),()=>{var o;r.delete(n),r.size||null===(o=t.get(e))||void 0===o||o.delete(l)}},effect(e,t,c){const l=function(e,t){var o,c;const l=null!==(o=n.get(e))&&void 0!==o?o:new Map,r=null!==(c=l.get(t))&&void 0!==c?c:[];return l.set(t,r),n.set(e,l),r}(e,o(c));return l.push(t),()=>{const e=l.indexOf(t);0>e||l.splice(e,1)}},async emit(c,l,r){var a,i,s;const u=o(r),f=null===(a=t.get(c))||void 0===a?void 0:a.get(u);if(!(null==f?void 0:f.size))return;const d=e(l,u),v=(null!==(s=null===(i=n.get(c))||void 0===i?void 0:i.get(u))&&void 0!==s?s:[]).reduceRight((e,t)=>t(e),async e=>{for(const t of f)await t(e)});await v(d)},scope:m}}function S(){const e=[],t=()=>t=>e.reduceRight((e,t)=>t(e),t);return t.takeLatest=()=>{let n=null;return e.push(e=>async t=>(null==n||n.abort(),n=new AbortController,e({...t,signal:n.signal}))),t},t.takeLeading=()=>{let n=!1;return e.push(e=>async t=>{if(!n){n=!0;try{return await e(t)}finally{n=!1}}}),t},t.debounce=n=>{let o;return e.push(e=>t=>new Promise(c=>{clearTimeout(o),o=setTimeout(()=>c(e(t)),n)})),t},t.throttle=n=>{let o=0;return e.push(e=>async t=>{const c=Date.now();if(c-o>=n)return o=c,e(t)}),t},t}export{s as batch,g as computed,d as createComputed,E as createIntentBus,v as createReactiveEffect,t as createScope,S as intentEffect,h as reactiveEffect,l as schedule,y as signal};
