function t(t){const e=new Map,n=new Map,o=new Map;return{on:function(t,n){var o;const r=null!==(o=e.get(t))&&void 0!==o?o:[];r.push(n),e.set(t,r)},effect:function(t,e){var o;const r=null!==(o=n.get(t))&&void 0!==o?o:[];r.push(e),n.set(t,r)},emit:async function(r,l,u){var a,c,s;const i=(e=>`${t}:${e}`)(r);null===(a=o.get(i))||void 0===a||a.abort();const f=new AbortController;o.set(i,f);const d=null!==(c=e.get(r))&&void 0!==c?c:[],p=null!==(s=n.get(r))&&void 0!==s?s:[];for(const e of d){let n=e;for(let t=p.length-1;t>=0;t--)n=p[t](n);await n({state:u.getState(),payload:l,signal:f.signal,scope:t,emit:u.emit,setState:u.setState})}}}}function e(t){return e=>t.reduceRight((t,e)=>e(t),e)}function n(){let t=null;return e=>async n=>(null==t||t.abort(),t=new AbortController,e({...n,signal:t.signal}))}function o(t){let e;return n=>o=>{clearTimeout(e),e=setTimeout(()=>{n(o)},t)}}function r(t=3){return e=>async n=>{let o;for(let r=0;r<t;r++)try{return await e(n)}catch(t){o=t}throw o}}function l(t){return function(e,n){let o=-1;return function r(l){var u;if(l<=o)return Promise.reject(new Error("next() called multiple times"));o=l;const a=null!==(u=t[l])&&void 0!==u?u:n;return Promise.resolve(a(e,()=>r(l+1)))}(0)}}function u(e,n="backend"){const o=structuredClone(e);let r=structuredClone(e);const l=t(n),u={getState:()=>r,setState(t){t(r)},emit:s};let a=!1,c=[];async function s(t,e){a?c.push({intent:t,payload:e}):await l.emit(t,e,u)}async function i(){const t=c;c=[];for(const e of t)await s(e.intent,e.payload)}return{state:()=>r,snapshot:()=>structuredClone(r),setState(t){t(r)},replaceState(t){r=structuredClone(t)},reset(){r=structuredClone(o)},emit:s,batch(t){a=!0;try{const e=t();if(e instanceof Promise)return e.finally(()=>(a=!1,i()))}finally{return a=!1,i()}},onIntent:l.on,effect:l.effect}}export{l as compose,e as composeEffects,u as createBackendRuntime,t as createIntentBus,o as debounce,r as retry,n as takeLatest};
